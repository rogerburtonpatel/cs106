TODO ASK: 
In our own compiler, we are going to arrange things upstream so that nested let expressions can be floated without renaming x.

So, how much freeIn checking do we need to do? 


ùíú‚ü¶let x = e in e'‚üß = normalizeLet ‚ü¶x‚üß (ùíú‚ü¶e‚üß)  (ùíú‚ü¶e'‚üß)
normalizeLet ‚ü¶x‚üß ‚ü¶let y = e‚ÇÅ in e‚ÇÇ‚üß ‚ü¶e‚ÇÉ‚üß = ‚ü¶let y = e‚ÇÅ in $(normalizeLet ‚ü¶x‚üß ‚ü¶e‚ÇÇ‚üß ‚ü¶e‚ÇÉ‚üß)‚üß, where y is not free in e‚ÇÉ

normalizeBegin (A.BEGIN (e1, e2)) e3 = normalizeBegin e1 (normalizeBegin e2 e3)
normalizeBegin e1 e2 = A.BEGIN (e1, e2)
  (* (begin (begin e1 e2) e3)  = (begin e1 (begin e2 e3) *)
  (* (begin (begin (begin e0 e1) e2) e3)  = normalizeBegin (begin e0 e1) (normalizeBegin e2 e3) *)
  (* normalizeBegin (begin e0 e1) (normalizeBegin e2 e3) = normalizeBegin e0 (normalizeBegin e1 (normalizeBegin e2 e3)) *)
  (* normalizeBegin e0 (normalizeBegin e1 (normalizeBegin e2 e3)) = A.BEGIN (e0, (normalizeBegin e1 (normalizeBegin e2 e3)) *)
  (* A.BEGIN (e0, A.BEGIN (e1 (normalizeBegin e2 e3))) *)
  (* A.BEGIN (e0, A.BEGIN (e1, (A.BEGIN e2 e3))) *)


Base case: 
A[[let x = SIMPLE ex in ex']] = let x = ex in ex'

float case of case 

float whiles-- chapter 2 semantics! 

             1       a     b                         a              b
A[[let x = (let y = ey in ey') in ex']] = A[[let y = ey in (let x = ey' in ex')]]

todo: y can't be free in what?
            1  a b  c                                a 
A[[let x = (if e e1 e2) in ex']]        = A[[let y = e in (if y       b
                                                            (let x = e1 in ex')
                                                                      c
                                                            (let x = e2 in ex'))]]

                                                            WRONG WHILE! book todo
            1          a    b                              a
A[[let x = (while y := e in e') in ex']]  = A[[(while y := e in 
                                                    b 
                                          (let x := e' in ex'))]]

            1     a    b                        a              b
A[[let x = (begin e1; e2) in ex']]  = A[[(begin e1; (let x := e2 in ex'))]]

BUT ey' is another let? We need recursive application, but i'm not quite sure 
how to normalize yet. Can we do it without a continuation?

For the depth point that checks for let-bound variables not being free in 
enclosing lets in KNF: 

the issue is that a variable that is bound in a let may not be bound in an 
enclosing let, or even on the right-hand side of an enclosing let. 
Otherwise you run into trouble not just with let but also with begin.

what is an enclosing let? can we check this invariant here, when we might 
have illegal forms?
