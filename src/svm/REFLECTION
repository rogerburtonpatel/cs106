1. It is convenient to be able to use new without delete or malloc without free.
But it is even more convenient to write code without thinking about allocation
at all. To claim this point, give an example from a language not in the Scheme
family, where the implementation of a feature just allocates behind the scenes,
and the garbage collector takes care of the rest. To earn the point, it must be
a feature that a programmer can use without being forced to think, “I am
allocating memory here.”

> I bet no one else will say python! 
  I can make a list:

  items = [1, 2, 3]

  concat another list to it:

  items += [3, 4]

  make a set out of it:

  item_set = set(items)

  All without EVER thinking about how much memory I need allocated, what copying
  I need to do, what's live or dead... 

  The data structures in python: lists, sets, etc- all allocate behind the 
  scenes, and dead objects (structures that go out of scope, etc) are 
  recycled. That's a beauty of the language; you can think about algorithms
  closer to the mathematical level than the hardware level. 


2. To claim this point, get your SVM into shape where you can run it on a program
and Valgrind reports no errors and no leaks. (You are welcome to do this in step
14, before you start your garbage collector.) Commit the code and tag it with
git tag valgrind-clean.
Submit the output from valgrind running your SVM on the
program of your choice.

> 

3. To claim this point, identify the lines in your scan_vmstate function that scan
registers and literals, and explain how you know which registers and literals to
scan.

4. To claim this point, look at the lines in your source code that initialize the
payload for a ConsCell, and identify the line that initializes the payload’s
forwarded pointer to NULL.

5. If a value that is gray or black were accidentally put on the gray list a second
time, this would violate one of the color invariants. To claim this point,
explain what bad thing could happen if this invariant is violated.

6. In step 19, I observe that my VMSAVE macro flushes the current register-window
pointer. But my VMLOAD does not reload it. To claim this point, explain why I
would bother to save this value if I’m not reloading it.

7. To claim this point, explain why it’s not possible to forward a pointer of type
Instruction *.

8. Function forward_string copies a payload only if the forwarding pointer is NULL.
To claim this point, suppose instead that forward_string copies a payload
unconditionally every time it is called, and explain what could go wrong.

9. To claim this point, say how you would set the heap-growth policy parameter to
do less work by using a lot of space. Then say how you would change the policy
to use less space at the cost of doing more work. If possible, support your
answer with evidence of gcstats output from your collector. If not, explain why
it is not possible.

10. In file value.c, function eqvalue compares two String values as equal only if
they point to the same payload—if two Values point to different payloads they
are considered different strings, even if the payloads contain the same
characters.

Suppose that a string value appears in two different VM registers, so both
registers point to the same payload. But then the garbage collector copies every
register’s payload to a new location. To claim this point, explain how the
collection manages to preserve pointer relationships so that after the
collection, the registers are still considered to hold equal strings.